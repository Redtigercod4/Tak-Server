"use strict";(self.webpackChunkdocusaurus_static=self.webpackChunkdocusaurus_static||[]).push([[60],{3213:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(5893),i=n(1151);const r={},o="Federation Example",s={id:"federation/federationexample",title:"Federation Example",description:'The figure below shows a connectivity graph of two distinct administrative domains.  Each administrative domain has multiple sub-groups (e.g. "CN=Alpha") utilizing the group-filtering.  The color coding indicates the CA that is used to sign the certificate used for connections.   Enclave 1\'s CA signs ATAK client certs and a server certificate.  Enclave 2\'s CA also signs ATAK client certs and a server cert.  The trust-store listing the allowed CAs for the "User Port" only contains a single CA (i.e. Enclave 1 CA for Enclave 1).  To federate the servers, Enclave 1 and Enclave 2 send each other the "public" CA cert.  Those certificates are put in a separate trust store that is used only for federation connections.  The \u201cFed. Port\u201d is configured with this separate trust-store.',source:"@site/docs/federation/federationexample.md",sourceDirName:"federation",slug:"/federation/federationexample",permalink:"/docs/federation/federationexample",draft:!1,unlisted:!1,editUrl:"https://gitlab.com/octospacc/editocttrialTools/-/blob/main/docusaurus-static/docs/federation/federationexample.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data Package and Mission File Blocker",permalink:"/docs/federation/datapackagemissionfileblocker"},next:{title:"Metrics",permalink:"/docs/metrics"}},c={},d=[{value:"Alternate Configuration",id:"alternate-configuration",level:2}];function l(e){const t={h1:"h1",h2:"h2",img:"img",p:"p",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"federation-example",children:"Federation Example"}),"\n",(0,a.jsx)(t.p,{children:'The figure below shows a connectivity graph of two distinct administrative domains.  Each administrative domain has multiple sub-groups (e.g. "CN=Alpha") utilizing the group-filtering.  The color coding indicates the CA that is used to sign the certificate used for connections.   Enclave 1\'s CA signs ATAK client certs and a server certificate.  Enclave 2\'s CA also signs ATAK client certs and a server cert.  The trust-store listing the allowed CAs for the "User Port" only contains a single CA (i.e. Enclave 1 CA for Enclave 1).  To federate the servers, Enclave 1 and Enclave 2 send each other the "public" CA cert.  Those certificates are put in a separate trust store that is used only for federation connections.  The \u201cFed. Port\u201d is configured with this separate trust-store.\nThe server cert from each administrative domain can now be used to connect to the "Fed. Port" of the other domain.'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Federation Example",src:n(584).Z+"",width:"560",height:"416"})}),"\n",(0,a.jsx)(t.h2,{id:"alternate-configuration",children:"Alternate Configuration"}),"\n",(0,a.jsx)(t.p,{children:"The first example had each federate using the same CA and server certificate for local and federate connections.  If you are very paranoid, or don't want to share anything about the crypto being used for local clients, you can have a wholly separate CA+server certificate chain that is used for federation.  Figure 5 shows how this would work."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Alternate Federation Example",src:n(584).Z+"",width:"560",height:"416"})}),"\n",(0,a.jsx)(t.p,{children:"This adds some complexity, but can be used if you don't want to expose your 'internal' CA to the organizations that you are federating with."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},584:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/fed_10-25b8d73c33c3f42065f26e4cf9ca0de4.png"},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>o});var a=n(7294);const i={},r=a.createContext(i);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);